{"version":3,"file":"index.module.js","sources":["../src/tools/brush/brushHelpers.ts","../src/utils/cursors.ts","../src/tools/brush/useBrush.ts","../src/tools/marker/useMarker.ts","../src/tools/airbrush/useAirbrush.ts","../src/tools/shading/useShadingBrush.ts","../src/tools/watercolor/watercolor.ts","../src/tools/watercolor/useWatercolor.ts","../src/tools/eraser/useEraser.ts","../src/utils/pointUtils.ts","../src/components/Artboard.tsx","../src/history.ts"],"sourcesContent":["import tinycolor from \"tinycolor2\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\n\r\nexport function varyColour(\r\n  sourceColour: string,\r\n  varyBrightness: number\r\n): string {\r\n  const amount = Math.round(Math.random() * varyBrightness);\r\n  const alpha = 1 - Math.random() / 4;\r\n  const colour = tinycolor(sourceColour);\r\n  const varied = colour.darken(amount - varyBrightness / 2).setAlpha(alpha);\r\n  return varied.toPercentageRgbString();\r\n}\r\n\r\nexport interface Bristle {\r\n  distance: number;\r\n  thickness: number;\r\n  colour: string;\r\n}\r\n\r\nexport const rotatePoint = (\r\n  distance: number,\r\n  angle: number,\r\n  origin: Point\r\n): Point => [\r\n  origin[0] + distance * Math.cos(angle),\r\n  origin[1] + distance * Math.sin(angle),\r\n];\r\n\r\nexport const getBearing = (origin: Point, destination: Point): number =>\r\n  (Math.atan2(destination[1] - origin[1], destination[0] - origin[0]) -\r\n    Math.PI / 2) %\r\n  (Math.PI * 2);\r\n\r\nexport const getNewAngle = (\r\n  origin: Point,\r\n  destination: Point,\r\n  oldAngle?: number\r\n): number => {\r\n  const bearing = getBearing(origin, destination);\r\n  if (typeof oldAngle === \"undefined\") {\r\n    return bearing;\r\n  }\r\n  return oldAngle - angleDiff(oldAngle, bearing);\r\n};\r\n\r\nexport const angleDiff = (angleA: number, angleB: number): number => {\r\n  const twoPi = Math.PI * 2;\r\n  const diff =\r\n    ((angleA - (angleB > 0 ? angleB : angleB + twoPi) + Math.PI) % twoPi) -\r\n    Math.PI;\r\n  return diff < -Math.PI ? diff + twoPi : diff;\r\n};\r\n","export function circleSVG(diameter: number) {\r\n  return `<svg xmlns='http://www.w3.org/2000/svg' width='${diameter}' height='${diameter}' viewBox='0 0 ${diameter} ${diameter}'><circle r='${\r\n    diameter / 2\r\n  }' cy='${diameter / 2}' cx='${\r\n    diameter / 2\r\n  }' stroke-width='1' stroke='rgba(0,0,0,0.5)' fill='none'/></svg>`;\r\n}\r\n\r\nexport function circleDataUri(diameter: number) {\r\n  return `data:image/svg+xml;base64,${btoa(circleSVG(diameter))}`;\r\n}\r\n\r\nexport function circleCursor(diameter: number) {\r\n  return `url(${circleDataUri(diameter)}) ${diameter / 2} ${\r\n    diameter / 2\r\n  }, crosshair`;\r\n}\r\n","import { useCallback, useRef, useState } from \"react\";\r\n\r\nimport { Bristle, getNewAngle, rotatePoint, varyColour } from \"./brushHelpers\";\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\n\r\nexport type Brush = Array<Bristle>;\r\n\r\nfunction makeBrush(\r\n  strokeWidth: number,\r\n  colour: string,\r\n  varyBrightness: number\r\n): Brush {\r\n  const brush: Brush = [];\r\n  const bristleCount = Math.round(strokeWidth / 3);\r\n  const gap = strokeWidth / bristleCount;\r\n  for (let i = 0; i < bristleCount; i++) {\r\n    const distance =\r\n      i === 0 ? 0 : gap * i + (Math.random() * gap) / 2 - gap / 2;\r\n    brush.push({\r\n      distance,\r\n      thickness: Math.random() * 2 + 2,\r\n      colour: varyColour(colour, varyBrightness),\r\n    });\r\n  }\r\n  return brush;\r\n}\r\n\r\nconst strokeBristle = (\r\n  origin: Point,\r\n  destination: Point,\r\n  bristle: Bristle,\r\n  controlPoint: Point,\r\n  context: CanvasRenderingContext2D\r\n) => {\r\n  context.beginPath();\r\n  context.moveTo(origin[0], origin[1]);\r\n  context.strokeStyle = bristle.colour;\r\n  context.lineWidth = bristle.thickness;\r\n  context.lineCap = \"round\";\r\n  context.lineJoin = \"round\";\r\n  context.shadowColor = bristle.colour;\r\n  context.shadowBlur = bristle.thickness / 2;\r\n  context.quadraticCurveTo(\r\n    controlPoint[0],\r\n    controlPoint[1],\r\n    destination[0],\r\n    destination[1]\r\n  );\r\n  context.lineTo(destination[0], destination[1]);\r\n  context.stroke();\r\n};\r\n\r\nconst drawStroke = (\r\n  bristles: Brush,\r\n  origin: Point,\r\n  destination: Point,\r\n  oldAngle: number,\r\n  newAngle: number,\r\n  strokeWidth: number,\r\n  context: CanvasRenderingContext2D\r\n) => {\r\n  bristles.forEach((bristle) => {\r\n    context.beginPath();\r\n    const bristleOrigin = rotatePoint(\r\n      bristle.distance - strokeWidth / 2,\r\n      oldAngle,\r\n      origin\r\n    );\r\n\r\n    const bristleDestination = rotatePoint(\r\n      bristle.distance - strokeWidth / 2,\r\n      newAngle,\r\n      destination\r\n    );\r\n    const controlPoint = rotatePoint(\r\n      bristle.distance - strokeWidth / 2,\r\n      newAngle,\r\n      origin\r\n    );\r\n\r\n    strokeBristle(\r\n      bristleOrigin,\r\n      bristleDestination,\r\n      bristle,\r\n      controlPoint,\r\n      context\r\n    );\r\n  });\r\n};\r\n\r\nexport interface UseBrushProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n  varyBrightness?: number;\r\n}\r\n\r\nexport function useBrush({\r\n  color = \"#000000\",\r\n  strokeWidth = 25,\r\n  varyBrightness = 5,\r\n}: UseBrushProps): ToolHandlers {\r\n  const [brush, setBrush] = useState<Brush>([]);\r\n  const currentAngle = useRef<number>();\r\n  const lastPoint = useRef<Point>();\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point) => {\r\n      currentAngle.current = undefined;\r\n      setBrush(makeBrush(strokeWidth, color, varyBrightness));\r\n      lastPoint.current = point;\r\n    },\r\n    [setBrush, strokeWidth, color, varyBrightness]\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\r\n      if (!lastPoint.current) {\r\n        lastPoint.current = newPoint;\r\n        return;\r\n      }\r\n      const newAngle = getNewAngle(\r\n        lastPoint.current,\r\n        newPoint,\r\n        currentAngle.current\r\n      );\r\n      if (typeof currentAngle.current === \"undefined\") {\r\n        currentAngle.current = newAngle % (Math.PI * 2);\r\n      }\r\n      drawStroke(\r\n        brush,\r\n        lastPoint.current,\r\n        newPoint,\r\n        currentAngle.current,\r\n        newAngle,\r\n        strokeWidth,\r\n        context\r\n      );\r\n      currentAngle.current = newAngle % (Math.PI * 2);\r\n      lastPoint.current = newPoint;\r\n    },\r\n    [brush, strokeWidth]\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Paintbrush\", startStroke, continueStroke, cursor };\r\n}\r\n","import { useCallback, useRef } from \"react\";\r\n\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\nexport interface UseMarkerProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n}\r\n\r\nexport function useMarker({\r\n  color = \"#000000\",\r\n  strokeWidth = 25,\r\n}: UseMarkerProps): ToolHandlers {\r\n  const lastPoint = useRef<Point>();\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.lineWidth = 3;\r\n      context.lineJoin = context.lineCap = \"round\";\r\n      lastPoint.current = point;\r\n      context.strokeStyle = color;\r\n    },\r\n    [color]\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\r\n      if (!lastPoint.current) {\r\n        lastPoint.current = newPoint;\r\n        return;\r\n      }\r\n      if (\r\n        lastPoint.current[0] === newPoint[0] &&\r\n        lastPoint.current[1] === newPoint[1]\r\n      ) {\r\n        return;\r\n      }\r\n      context.beginPath();\r\n\r\n      for (let i = 0; i < strokeWidth; i += 2) {\r\n        const offset = Math.round(strokeWidth / 2 - i);\r\n        context.globalAlpha = (1 / strokeWidth) * (strokeWidth - i);\r\n        context.moveTo(\r\n          lastPoint.current[0] - offset,\r\n          lastPoint.current[1] - offset\r\n        );\r\n        context.lineTo(newPoint[0] - offset, newPoint[1] - offset);\r\n        context.stroke();\r\n      }\r\n      context.globalAlpha = 1;\r\n      context.beginPath();\r\n\r\n      lastPoint.current = newPoint;\r\n    },\r\n    [strokeWidth, lastPoint]\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Marker pen\", startStroke, continueStroke, cursor };\r\n}\r\n","import { useCallback } from \"react\";\r\nimport tinycolor from \"tinycolor2\";\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\nexport interface UseAirbrushProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n}\r\n\r\nexport function useAirbrush({\r\n  color = \"#000000\",\r\n  strokeWidth = 25,\r\n}: UseAirbrushProps): ToolHandlers {\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.globalCompositeOperation = \"darken\";\r\n      context.lineWidth = strokeWidth;\r\n      context.lineJoin = context.lineCap = \"round\";\r\n      context.strokeStyle = color;\r\n      context.shadowBlur = strokeWidth * 0.5;\r\n      context.shadowColor = tinycolor(color)\r\n        .setAlpha(0.5)\r\n        .toPercentageRgbString();\r\n      console.log(context.shadowColor);\r\n      context.moveTo(point[0], point[1]);\r\n      context.beginPath();\r\n    },\r\n    [color, strokeWidth]\r\n  );\r\n\r\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\r\n    context.globalCompositeOperation = \"source-over\";\r\n  }, []);\r\n\r\n  const continueStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.lineTo(point[0], point[1]);\r\n      context.stroke();\r\n    },\r\n    []\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Airbrush\", startStroke, continueStroke, endStroke, cursor };\r\n}\r\n","import { useCallback, useRef } from \"react\";\r\nimport tinycolor from \"tinycolor2\";\r\n\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nexport interface UseShadingProps {\r\n  color?: string;\r\n  neighbourColor?: string;\r\n  neighbourStrokeWidth?: number;\r\n  distanceThreshold?: number;\r\n  spreadFactor?: number;\r\n}\r\n\r\nexport function useShadingBrush({\r\n  color = \"#000000\",\r\n  neighbourColor,\r\n  distanceThreshold = 40,\r\n  neighbourStrokeWidth = 1,\r\n  spreadFactor = 0.9,\r\n}: UseShadingProps): ToolHandlers {\r\n  neighbourColor ||= tinycolor(color).setAlpha(0.2).toPercentageRgbString();\r\n  const points = useRef<Array<Point>>([]);\r\n  const threshold = distanceThreshold * distanceThreshold;\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.globalCompositeOperation = \"darken\";\r\n      context.lineWidth = 1;\r\n      context.lineJoin = context.lineCap = \"round\";\r\n      points.current = [point];\r\n    },\r\n    []\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\r\n      context.strokeStyle = color;\r\n      context.lineWidth = 1;\r\n\r\n      points.current.push(newPoint);\r\n      context.beginPath();\r\n      const [prevX, prevY] = points.current[points.current.length - 2];\r\n      context.moveTo(prevX, prevY);\r\n      context.lineTo(...newPoint);\r\n      context.stroke();\r\n      context.lineWidth = neighbourStrokeWidth;\r\n\r\n      for (const point of points.current) {\r\n        const dx = point[0] - newPoint[0];\r\n        const dy = point[1] - newPoint[1];\r\n        const distance = dx * dx + dy * dy;\r\n\r\n        if (distance < threshold && Math.random() > distance / threshold) {\r\n          context.beginPath();\r\n          context.strokeStyle = neighbourColor as string;\r\n          context.moveTo(\r\n            newPoint[0] + dx * spreadFactor,\r\n            newPoint[1] + dy * spreadFactor\r\n          );\r\n          context.lineTo(\r\n            point[0] - dx * spreadFactor,\r\n            point[1] - dy * spreadFactor\r\n          );\r\n          context.stroke();\r\n        }\r\n      }\r\n    },\r\n    [neighbourStrokeWidth, color, spreadFactor, threshold, neighbourColor]\r\n  );\r\n\r\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\r\n    context.globalCompositeOperation = \"source-over\";\r\n  }, []);\r\n  const cursor = \"crosshair\";\r\n\r\n  return { name: \"Shading\", startStroke, continueStroke, endStroke, cursor };\r\n}\r\n","import { Point } from \"../../utils/pointUtils\";\r\n\r\nlet spareRandom: number | null = null;\r\n\r\n// https://gist.github.com/bluesmoon/7925696\r\nfunction normalRandom() {\r\n  let val, u, v, s, mul;\r\n  if (spareRandom !== null) {\r\n    val = spareRandom;\r\n    spareRandom = null;\r\n  } else {\r\n    do {\r\n      u = Math.random() * 2 - 1;\r\n      v = Math.random() * 2 - 1;\r\n      s = u * u + v * v;\r\n    } while (s === 0 || s >= 1);\r\n    mul = Math.sqrt((-2 * Math.log(s)) / s);\r\n    val = u * mul;\r\n    spareRandom = v * mul;\r\n  }\r\n  return val;\r\n}\r\nexport function makePolygon(\r\n  centre: Point,\r\n  sides: number,\r\n  radius: number\r\n): Array<Point> {\r\n  const increment = (Math.PI * 2) / sides;\r\n  const result: Array<Point> = [];\r\n  for (let i = 1; i <= sides; i++) {\r\n    result.push([\r\n      radius * Math.cos(increment * i) + centre[0],\r\n      radius * Math.sin(increment * i) + centre[1],\r\n    ]);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function deformPolygon(\r\n  points: Array<Point>,\r\n  depth: number,\r\n  variance: number,\r\n  vdiv: number\r\n): Array<Point> {\r\n  const newPoints: Array<Point> = [];\r\n  for (let i = 0; i < points.length; i++) {\r\n    const currentPoint = points[i];\r\n    const nextPoint = points[(i + 1) % points.length];\r\n    newPoints.push(currentPoint);\r\n    newPoints.push(\r\n      ...subdivideVertex(currentPoint, nextPoint, depth, variance, vdiv)\r\n    );\r\n  }\r\n  return newPoints;\r\n}\r\n\r\nfunction subdivideVertex(\r\n  currentPoint: Point,\r\n  nextPoint: Point,\r\n  depth: number,\r\n  variance: number,\r\n  vdiv: number\r\n): Array<Point> {\r\n  if (depth < 0) {\r\n    return [];\r\n  }\r\n  //   Find the midpoint\r\n  const midX = (currentPoint[0] + nextPoint[0]) / 2;\r\n  const midY = (currentPoint[1] + nextPoint[1]) / 2;\r\n\r\n  //   Nudge the midpoint\r\n  const newMidpoint: Point = [\r\n    midX + normalRandom() * variance,\r\n    midY + normalRandom() * variance,\r\n  ];\r\n\r\n  const newPoints = subdivideVertex(\r\n    currentPoint,\r\n    newMidpoint,\r\n    depth - 1,\r\n    variance / vdiv,\r\n    vdiv\r\n  );\r\n\r\n  newPoints.push(newMidpoint);\r\n  newPoints.push(\r\n    ...subdivideVertex(newMidpoint, nextPoint, depth - 1, variance / vdiv, vdiv)\r\n  );\r\n  return newPoints;\r\n}\r\n\r\nexport function getSplodge(\r\n  point: Point,\r\n  sides: number,\r\n  radius: number\r\n): Array<Point> {\r\n  return deformPolygon(makePolygon(point, sides, radius), 5, radius / 10, 2);\r\n}\r\n\r\nexport function splodgeAtPoint(\r\n  point: Point,\r\n  context: CanvasRenderingContext2D,\r\n  width: number\r\n): void {\r\n  context.beginPath();\r\n  getSplodge(point, Math.round(width / 5), width).forEach((point) => {\r\n    context.lineTo(...point);\r\n  });\r\n  context.closePath();\r\n  context.fill();\r\n}\r\n\r\nexport function splodgeTrail(\r\n  points: Array<Point>,\r\n  width: number,\r\n  trail: number,\r\n  context: CanvasRenderingContext2D\r\n): void {\r\n  const count = Math.min(trail, points.length / 3);\r\n  for (let i = 0; i < count; i++) {\r\n    context.globalAlpha = 0.01 - (0.009 / count) * i;\r\n    splodgeAtPoint(\r\n      points[points.length - i * 3 - 1],\r\n      context,\r\n      width + (width / count) * i\r\n    );\r\n  }\r\n  context.globalAlpha = 0.1;\r\n}\r\n","import { useCallback, useRef } from \"react\";\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\nimport { splodgeTrail } from \"./watercolor\";\r\n\r\nexport interface UseWatercolorProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n}\r\n\r\nexport function useWatercolor({\r\n  color = \"#000000\",\r\n  strokeWidth = 25,\r\n}: UseWatercolorProps): ToolHandlers {\r\n  const points = useRef<Array<Point>>([]);\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.fillStyle = color;\r\n      context.shadowColor = color;\r\n      context.globalAlpha = 0.01;\r\n      points.current = [point];\r\n      splodgeTrail(points.current, strokeWidth * 1.1, 1, context);\r\n    },\r\n    [color, strokeWidth]\r\n  );\r\n\r\n  const endStroke = useCallback(() => {\r\n    points.current = [];\r\n  }, []);\r\n\r\n  const continueStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      points.current.push(point);\r\n      splodgeTrail(points.current, strokeWidth, 5, context);\r\n    },\r\n    [strokeWidth]\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Watercolor\", startStroke, continueStroke, endStroke, cursor };\r\n}\r\n","import { useCallback } from \"react\";\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\nexport interface UseEraserProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n}\r\n\r\nexport function useEraser({ strokeWidth = 25 }: UseEraserProps): ToolHandlers {\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.globalCompositeOperation = \"source-over\";\r\n\r\n      context.lineWidth = strokeWidth;\r\n      context.strokeStyle = \"#ffffff\";\r\n      context.lineJoin = context.lineCap = \"round\";\r\n      context.moveTo(point[0], point[1]);\r\n      context.beginPath();\r\n    },\r\n    [strokeWidth]\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.lineTo(point[0], point[1]);\r\n      context.stroke();\r\n    },\r\n    []\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Eraser\", startStroke, continueStroke, cursor };\r\n}\r\n","export type Point = [number, number];\r\n\r\nexport const getTouchPoint = (event: React.TouchEvent): Point => {\r\n  if (!event.currentTarget) {\r\n    return [0, 0];\r\n  }\r\n  const rect = event.currentTarget.getBoundingClientRect();\r\n  const touch = event.targetTouches[0];\r\n  return [touch.clientX - rect.left, touch.clientY - rect.top];\r\n};\r\n\r\nexport const getMousePoint = (event: React.MouseEvent): Point => [\r\n  event.nativeEvent.offsetX,\r\n  event.nativeEvent.offsetY,\r\n];\r\n\r\nconst BUTTON = 0b01;\r\nexport const mouseButtonIsDown = (buttons: number): boolean =>\r\n  (BUTTON & buttons) === BUTTON;\r\n","import React, {\r\n  ForwardedRef,\r\n  forwardRef,\r\n  useCallback,\r\n  useImperativeHandle,\r\n  useState,\r\n} from \"react\";\r\n\r\nimport { History } from \"../history\";\r\n\r\nimport {\r\n  getMousePoint,\r\n  getTouchPoint,\r\n  mouseButtonIsDown,\r\n  Point,\r\n} from \"../utils/pointUtils\";\r\n\r\nexport interface ArtboardProps\r\n  extends React.CanvasHTMLAttributes<HTMLCanvasElement> {\r\n  tool: ToolHandlers;\r\n  history?: History;\r\n  onStartStroke?: (point: Point) => void;\r\n  onContinueStroke?: (point: Point) => void;\r\n  onEndStroke?: () => void;\r\n}\r\n\r\nexport interface ArtboardRef {\r\n  download: (filename?: string, type?: string) => void;\r\n  getImageAsDataUri: (type?: string) => string | undefined;\r\n  clear: () => void;\r\n  context?: CanvasRenderingContext2D | null;\r\n}\r\n\r\nexport interface ToolHandlers {\r\n  name: string;\r\n  startStroke?: (point: Point, context: CanvasRenderingContext2D) => void;\r\n  continueStroke?: (point: Point, context: CanvasRenderingContext2D) => void;\r\n  endStroke?: (context: CanvasRenderingContext2D) => void;\r\n  cursor?: string;\r\n}\r\n\r\nexport const Artboard = forwardRef(function Artboard(\r\n  {\r\n    tool,\r\n    style,\r\n    history,\r\n    onStartStroke,\r\n    onContinueStroke,\r\n    onEndStroke,\r\n    ...props\r\n  }: ArtboardProps,\r\n  ref: ForwardedRef<ArtboardRef>\r\n) {\r\n  const [context, setContext] = useState<CanvasRenderingContext2D | null>();\r\n  const [canvas, setCanvas] = useState<HTMLCanvasElement>();\r\n  const [drawing, setDrawing] = useState(false);\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point) => {\r\n      if (!context) {\r\n        return;\r\n      }\r\n      context.save();\r\n      setDrawing(true);\r\n      tool.startStroke?.(point, context);\r\n      onStartStroke?.(point);\r\n    },\r\n    [tool, context, onStartStroke]\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (newPoint: Point) => {\r\n      if (!context) {\r\n        return;\r\n      }\r\n      tool.continueStroke?.(newPoint, context);\r\n      onContinueStroke?.(newPoint);\r\n    },\r\n    [tool, context, onContinueStroke]\r\n  );\r\n\r\n  const endStroke = useCallback(() => {\r\n    setDrawing(false);\r\n    if (context) {\r\n      tool.endStroke?.(context);\r\n      onEndStroke?.();\r\n      context.restore();\r\n      if (canvas && history) {\r\n        history.pushState(canvas);\r\n      }\r\n    }\r\n  }, [tool, context, canvas, history, onEndStroke]);\r\n\r\n  const mouseMove = useCallback(\r\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (!drawing) {\r\n        return;\r\n      }\r\n      continueStroke(getMousePoint(event));\r\n    },\r\n    [continueStroke, drawing]\r\n  );\r\n\r\n  const touchMove = useCallback(\r\n    (event: React.TouchEvent) => {\r\n      if (!drawing) {\r\n        return;\r\n      }\r\n      continueStroke(getTouchPoint(event));\r\n    },\r\n    [continueStroke, drawing]\r\n  );\r\n\r\n  const mouseDown = useCallback(\r\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (drawing) {\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      startStroke(getMousePoint(event));\r\n    },\r\n    [drawing, startStroke]\r\n  );\r\n\r\n  const touchStart = useCallback(\r\n    (event: React.TouchEvent) => {\r\n      if (drawing) {\r\n        return;\r\n      }\r\n      startStroke(getTouchPoint(event));\r\n    },\r\n    [drawing, startStroke]\r\n  );\r\n\r\n  const clear = useCallback(() => {\r\n    if (!context || !canvas) {\r\n      return;\r\n    }\r\n    context.save();\r\n    context.fillStyle = \"rgba(255, 255, 255, 0)\";\r\n    context.fillRect(0, 0, canvas.width, canvas.height);\r\n    context.restore();\r\n    if (canvas && history) {\r\n      history.pushState(canvas);\r\n    }\r\n  }, [context, canvas, history]);\r\n\r\n  const gotRef = useCallback(\r\n    (canvasRef: HTMLCanvasElement) => {\r\n      if (!canvasRef) {\r\n        return;\r\n      }\r\n      canvasRef.width = canvasRef.offsetWidth;\r\n      canvasRef.height = canvasRef.offsetHeight;\r\n      const ctx = canvasRef.getContext(\"2d\");\r\n      setCanvas(canvasRef);\r\n      setContext(ctx);\r\n      if (!ctx) {\r\n        return;\r\n      }\r\n      ctx.fillStyle = \"rgba(255, 255, 255, 0)\";\r\n      ctx.fillRect(0, 0, canvasRef.width, canvasRef.height);\r\n      ctx.fillStyle = \"transparent\";\r\n      if (history) {\r\n        history.setContext(ctx);\r\n        history.pushState(canvasRef);\r\n      }\r\n    },\r\n    [history]\r\n  );\r\n\r\n  const mouseEnter = useCallback(\r\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (mouseButtonIsDown(event.buttons)) {\r\n        mouseDown(event);\r\n      } else if (drawing) {\r\n        endStroke();\r\n      }\r\n    },\r\n    [drawing, mouseDown, endStroke]\r\n  );\r\n\r\n  const mouseLeave = useCallback(\r\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (!drawing) {\r\n        return;\r\n      }\r\n      continueStroke(getMousePoint(event));\r\n      endStroke();\r\n    },\r\n    [continueStroke, drawing, endStroke]\r\n  );\r\n\r\n  useImperativeHandle(\r\n    ref,\r\n    () => ({\r\n      download: (filename = \"image.png\", type?: string) => {\r\n        if (!canvas) {\r\n          return;\r\n        }\r\n        const a = document.createElement(\"a\");\r\n        a.href = canvas.toDataURL(type);\r\n        a.download = filename;\r\n        a.click();\r\n      },\r\n      clear,\r\n      getImageAsDataUri: (type?: string) => canvas?.toDataURL(type),\r\n      context,\r\n    }),\r\n    [canvas, context, clear]\r\n  );\r\n\r\n  return (\r\n    <canvas\r\n      style={{ cursor: tool?.cursor, touchAction: \"none\", ...style }}\r\n      onTouchStart={touchStart}\r\n      onMouseDown={mouseDown}\r\n      onMouseEnter={mouseEnter}\r\n      onMouseMove={drawing ? mouseMove : undefined}\r\n      onTouchMove={drawing ? touchMove : undefined}\r\n      onMouseUp={endStroke}\r\n      onMouseOut={mouseLeave}\r\n      onTouchEnd={endStroke}\r\n      ref={gotRef}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\n","import { useCallback, useMemo, useRef, useState } from \"react\";\r\n\r\nasync function applyImage(context: CanvasRenderingContext2D, blob: Blob) {\r\n  const img = new Image();\r\n  img.onload = () => {\r\n    context.canvas.width = img.width;\r\n    context.canvas.height = img.height;\r\n    context.drawImage(img, 0, 0);\r\n    URL.revokeObjectURL(img.src);\r\n  };\r\n  img.src = URL.createObjectURL(blob);\r\n}\r\n\r\nexport interface History {\r\n  setContext: (context: CanvasRenderingContext2D) => void;\r\n  pushState: (canvas: HTMLCanvasElement) => Promise<boolean>;\r\n}\r\nexport interface HistoryHook {\r\n  history: History;\r\n\r\n  undo: () => Promise<boolean>;\r\n  redo: () => Promise<boolean>;\r\n  clear: () => void;\r\n  canUndo: boolean;\r\n  canRedo: boolean;\r\n}\r\n\r\nexport function useHistory(size?: number): HistoryHook {\r\n  const stack = useRef<Array<Blob>>([]);\r\n  const crs = useRef(0);\r\n  const [context, setContext] = useState<CanvasRenderingContext2D>();\r\n  const [canUndo, setCanUndo] = useState(false);\r\n  const [canRedo, setCanRedo] = useState(false);\r\n\r\n  const pushState = useCallback(\r\n    async (canvas: HTMLCanvasElement) => {\r\n      const undoCursor = crs.current;\r\n      if (!context) {\r\n        console.error(\"Context not initialised\");\r\n        return false;\r\n      }\r\n      if (undoCursor !== 0) {\r\n        stack.current = stack.current.slice(0, -undoCursor);\r\n        crs.current = 0;\r\n      }\r\n      const blob = await new Promise<Blob | null>((resolve) =>\r\n        canvas.toBlob(resolve)\r\n      );\r\n      if (blob) {\r\n        stack.current.push(blob);\r\n      }\r\n      if (size && stack.current.length > size) {\r\n        stack.current = stack.current.slice(-size);\r\n      }\r\n      setCanUndo(stack.current.length > 1);\r\n      setCanRedo(false);\r\n      return true;\r\n    },\r\n    [crs, stack, context]\r\n  );\r\n  const undo = useCallback(async () => {\r\n    const undoCursor = crs.current;\r\n\r\n    if (!context) {\r\n      console.error(\"Context not initialised\");\r\n      return false;\r\n    }\r\n    if (undoCursor + 1 >= stack.current.length) {\r\n      console.log(\"nope\");\r\n      return false;\r\n    }\r\n\r\n    await applyImage(\r\n      context,\r\n      stack.current[stack.current.length - (undoCursor + 2)]\r\n    );\r\n    crs.current++;\r\n    setCanUndo(crs.current + 1 < stack.current.length);\r\n    setCanRedo(true);\r\n    return true;\r\n  }, [crs, stack, context]);\r\n\r\n  const redo = useCallback(async () => {\r\n    const undoCursor = crs.current;\r\n\r\n    if (!context) {\r\n      console.error(\"Context not initialised\");\r\n      return false;\r\n    }\r\n    if (undoCursor <= 0) {\r\n      return false;\r\n    }\r\n\r\n    await applyImage(context, stack.current[stack.current.length - undoCursor]);\r\n    crs.current--;\r\n    setCanUndo(crs.current + 1 < stack.current.length);\r\n    setCanRedo(crs.current > 0);\r\n    return true;\r\n  }, [stack, crs, context]);\r\n\r\n  const clear = useCallback(() => {\r\n    stack.current = [];\r\n  }, [stack]);\r\n\r\n  const history = useMemo<History>(\r\n    () => ({\r\n      setContext: (context: CanvasRenderingContext2D) => {\r\n        setContext(context);\r\n      },\r\n      pushState,\r\n    }),\r\n    [setContext, pushState]\r\n  );\r\n\r\n  return { history, undo, redo, clear, canUndo, canRedo };\r\n}\r\n"],"names":["varyColour","sourceColour","varyBrightness","amount","Math","round","random","alpha","tinycolor","darken","setAlpha","toPercentageRgbString","rotatePoint","distance","angle","origin","cos","sin","circleCursor","diameter","btoa","circleSVG","circleDataUri","useBrush","_ref","_ref$color","color","_ref$strokeWidth","strokeWidth","_ref$varyBrightness","_useState","useState","brush","setBrush","currentAngle","useRef","lastPoint","startStroke","useCallback","point","current","undefined","colour","bristleCount","gap","i","push","thickness","makeBrush","name","continueStroke","newPoint","context","newAngle","oldAngle","destination","bearing","atan2","PI","angleB","twoPi","diff","bristles","forEach","bristle","beginPath","controlPoint","moveTo","strokeStyle","lineWidth","lineCap","lineJoin","shadowColor","shadowBlur","quadraticCurveTo","lineTo","stroke","strokeBristle","drawStroke","cursor","useMarker","offset","globalAlpha","useAirbrush","globalCompositeOperation","console","log","endStroke","useShadingBrush","neighbourColor","_ref$distanceThreshol","distanceThreshold","_ref$neighbourStrokeW","neighbourStrokeWidth","_ref$spreadFactor","spreadFactor","points","threshold","_points$current","length","prevY","apply","_iterator","_step","_createForOfIteratorHelperLoose","done","value","dx","dy","spareRandom","normalRandom","val","u","v","s","mul","sqrt","subdivideVertex","currentPoint","nextPoint","depth","variance","vdiv","midY","newMidpoint","newPoints","splodgeAtPoint","width","sides","radius","deformPolygon","centre","increment","result","makePolygon","getSplodge","closePath","fill","splodgeTrail","trail","count","min","useWatercolor","fillStyle","useEraser","getTouchPoint","event","currentTarget","rect","getBoundingClientRect","touch","targetTouches","clientX","left","clientY","top","getMousePoint","nativeEvent","offsetX","offsetY","mouseButtonIsDown","buttons","Artboard","forwardRef","ref","tool","style","history","onStartStroke","onContinueStroke","onEndStroke","props","_objectWithoutPropertiesLoose","_excluded","setContext","_useState2","canvas","setCanvas","_useState3","drawing","setDrawing","save","restore","pushState","mouseMove","touchMove","mouseDown","preventDefault","touchStart","clear","fillRect","height","gotRef","canvasRef","offsetWidth","offsetHeight","ctx","getContext","mouseEnter","mouseLeave","useImperativeHandle","download","filename","type","a","document","createElement","href","toDataURL","click","getImageAsDataUri","React","_extends","touchAction","onTouchStart","onMouseDown","onMouseEnter","onMouseMove","onTouchMove","onMouseUp","onMouseOut","onTouchEnd","applyImage","blob","img","Image","onload","drawImage","URL","revokeObjectURL","src","createObjectURL","Promise","resolve","e","reject","useHistory","size","stack","crs","canUndo","setCanUndo","canRedo","setCanRedo","undoCursor","slice","toBlob","then","error","undo","redo","useMemo"],"mappings":"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"}