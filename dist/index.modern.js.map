{"version":3,"file":"index.modern.js","sources":["../src/tools/brush/brushHelpers.ts","../src/utils/cursors.ts","../src/tools/brush/useBrush.ts","../src/tools/marker/useMarker.ts","../src/tools/airbrush/useAirbrush.ts","../src/tools/shading/useShadingBrush.ts","../src/tools/watercolor/watercolor.ts","../src/tools/watercolor/useWatercolor.ts","../src/tools/eraser/useEraser.ts","../src/utils/pointUtils.ts","../src/components/Artboard.tsx","../src/history.ts"],"sourcesContent":["import tinycolor from \"tinycolor2\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\n\r\nexport function varyColour(\r\n  sourceColour: string,\r\n  varyBrightness: number\r\n): string {\r\n  const amount = Math.round(Math.random() * varyBrightness);\r\n  const alpha = 1 - Math.random() / 4;\r\n  const colour = tinycolor(sourceColour);\r\n  const varied = colour.darken(amount - varyBrightness / 2).setAlpha(alpha);\r\n  return varied.toPercentageRgbString();\r\n}\r\n\r\nexport interface Bristle {\r\n  distance: number;\r\n  thickness: number;\r\n  colour: string;\r\n}\r\n\r\nexport const rotatePoint = (\r\n  distance: number,\r\n  angle: number,\r\n  origin: Point\r\n): Point => [\r\n  origin[0] + distance * Math.cos(angle),\r\n  origin[1] + distance * Math.sin(angle),\r\n];\r\n\r\nexport const getBearing = (origin: Point, destination: Point): number =>\r\n  (Math.atan2(destination[1] - origin[1], destination[0] - origin[0]) -\r\n    Math.PI / 2) %\r\n  (Math.PI * 2);\r\n\r\nexport const getNewAngle = (\r\n  origin: Point,\r\n  destination: Point,\r\n  oldAngle?: number\r\n): number => {\r\n  const bearing = getBearing(origin, destination);\r\n  if (typeof oldAngle === \"undefined\") {\r\n    return bearing;\r\n  }\r\n  return oldAngle - angleDiff(oldAngle, bearing);\r\n};\r\n\r\nexport const angleDiff = (angleA: number, angleB: number): number => {\r\n  const twoPi = Math.PI * 2;\r\n  const diff =\r\n    ((angleA - (angleB > 0 ? angleB : angleB + twoPi) + Math.PI) % twoPi) -\r\n    Math.PI;\r\n  return diff < -Math.PI ? diff + twoPi : diff;\r\n};\r\n","export function circleSVG(diameter: number) {\r\n  return `<svg xmlns='http://www.w3.org/2000/svg' width='${diameter}' height='${diameter}' viewBox='0 0 ${diameter} ${diameter}'><circle r='${\r\n    diameter / 2\r\n  }' cy='${diameter / 2}' cx='${\r\n    diameter / 2\r\n  }' stroke-width='1' stroke='rgba(0,0,0,0.5)' fill='none'/></svg>`;\r\n}\r\n\r\nexport function circleDataUri(diameter: number) {\r\n  return `data:image/svg+xml;base64,${btoa(circleSVG(diameter))}`;\r\n}\r\n\r\nexport function circleCursor(diameter: number) {\r\n  return `url(${circleDataUri(diameter)}) ${diameter / 2} ${\r\n    diameter / 2\r\n  }, crosshair`;\r\n}\r\n","import { useCallback, useRef, useState } from \"react\";\r\n\r\nimport { Bristle, getNewAngle, rotatePoint, varyColour } from \"./brushHelpers\";\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\n\r\nexport type Brush = Array<Bristle>;\r\n\r\nfunction makeBrush(\r\n  strokeWidth: number,\r\n  colour: string,\r\n  varyBrightness: number\r\n): Brush {\r\n  const brush: Brush = [];\r\n  const bristleCount = Math.round(strokeWidth / 3);\r\n  const gap = strokeWidth / bristleCount;\r\n  for (let i = 0; i < bristleCount; i++) {\r\n    const distance =\r\n      i === 0 ? 0 : gap * i + (Math.random() * gap) / 2 - gap / 2;\r\n    brush.push({\r\n      distance,\r\n      thickness: Math.random() * 2 + 2,\r\n      colour: varyColour(colour, varyBrightness),\r\n    });\r\n  }\r\n  return brush;\r\n}\r\n\r\nconst strokeBristle = (\r\n  origin: Point,\r\n  destination: Point,\r\n  bristle: Bristle,\r\n  controlPoint: Point,\r\n  context: CanvasRenderingContext2D\r\n) => {\r\n  context.beginPath();\r\n  context.moveTo(origin[0], origin[1]);\r\n  context.strokeStyle = bristle.colour;\r\n  context.lineWidth = bristle.thickness;\r\n  context.lineCap = \"round\";\r\n  context.lineJoin = \"round\";\r\n  context.shadowColor = bristle.colour;\r\n  context.shadowBlur = bristle.thickness / 2;\r\n  context.quadraticCurveTo(\r\n    controlPoint[0],\r\n    controlPoint[1],\r\n    destination[0],\r\n    destination[1]\r\n  );\r\n  context.lineTo(destination[0], destination[1]);\r\n  context.stroke();\r\n};\r\n\r\nconst drawStroke = (\r\n  bristles: Brush,\r\n  origin: Point,\r\n  destination: Point,\r\n  oldAngle: number,\r\n  newAngle: number,\r\n  strokeWidth: number,\r\n  context: CanvasRenderingContext2D\r\n) => {\r\n  bristles.forEach((bristle) => {\r\n    context.beginPath();\r\n    const bristleOrigin = rotatePoint(\r\n      bristle.distance - strokeWidth / 2,\r\n      oldAngle,\r\n      origin\r\n    );\r\n\r\n    const bristleDestination = rotatePoint(\r\n      bristle.distance - strokeWidth / 2,\r\n      newAngle,\r\n      destination\r\n    );\r\n    const controlPoint = rotatePoint(\r\n      bristle.distance - strokeWidth / 2,\r\n      newAngle,\r\n      origin\r\n    );\r\n\r\n    strokeBristle(\r\n      bristleOrigin,\r\n      bristleDestination,\r\n      bristle,\r\n      controlPoint,\r\n      context\r\n    );\r\n  });\r\n};\r\n\r\nexport interface UseBrushProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n  varyBrightness?: number;\r\n}\r\n\r\nexport function useBrush({\r\n  color = \"#000000\",\r\n  strokeWidth = 25,\r\n  varyBrightness = 5,\r\n}: UseBrushProps): ToolHandlers {\r\n  const [brush, setBrush] = useState<Brush>([]);\r\n  const currentAngle = useRef<number>();\r\n  const lastPoint = useRef<Point>();\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point) => {\r\n      currentAngle.current = undefined;\r\n      setBrush(makeBrush(strokeWidth, color, varyBrightness));\r\n      lastPoint.current = point;\r\n    },\r\n    [setBrush, strokeWidth, color, varyBrightness]\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\r\n      if (!lastPoint.current) {\r\n        lastPoint.current = newPoint;\r\n        return;\r\n      }\r\n      const newAngle = getNewAngle(\r\n        lastPoint.current,\r\n        newPoint,\r\n        currentAngle.current\r\n      );\r\n      if (typeof currentAngle.current === \"undefined\") {\r\n        currentAngle.current = newAngle % (Math.PI * 2);\r\n      }\r\n      drawStroke(\r\n        brush,\r\n        lastPoint.current,\r\n        newPoint,\r\n        currentAngle.current,\r\n        newAngle,\r\n        strokeWidth,\r\n        context\r\n      );\r\n      currentAngle.current = newAngle % (Math.PI * 2);\r\n      lastPoint.current = newPoint;\r\n    },\r\n    [brush, strokeWidth]\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Paintbrush\", startStroke, continueStroke, cursor };\r\n}\r\n","import { useCallback, useRef } from \"react\";\r\n\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\nexport interface UseMarkerProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n}\r\n\r\nexport function useMarker({\r\n  color = \"#000000\",\r\n  strokeWidth = 25,\r\n}: UseMarkerProps): ToolHandlers {\r\n  const lastPoint = useRef<Point>();\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.lineWidth = 3;\r\n      context.lineJoin = context.lineCap = \"round\";\r\n      lastPoint.current = point;\r\n      context.strokeStyle = color;\r\n    },\r\n    [color]\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\r\n      if (!lastPoint.current) {\r\n        lastPoint.current = newPoint;\r\n        return;\r\n      }\r\n      if (\r\n        lastPoint.current[0] === newPoint[0] &&\r\n        lastPoint.current[1] === newPoint[1]\r\n      ) {\r\n        return;\r\n      }\r\n      context.beginPath();\r\n\r\n      for (let i = 0; i < strokeWidth; i += 2) {\r\n        const offset = Math.round(strokeWidth / 2 - i);\r\n        context.globalAlpha = (1 / strokeWidth) * (strokeWidth - i);\r\n        context.moveTo(\r\n          lastPoint.current[0] - offset,\r\n          lastPoint.current[1] - offset\r\n        );\r\n        context.lineTo(newPoint[0] - offset, newPoint[1] - offset);\r\n        context.stroke();\r\n      }\r\n      context.globalAlpha = 1;\r\n      context.beginPath();\r\n\r\n      lastPoint.current = newPoint;\r\n    },\r\n    [strokeWidth, lastPoint]\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Marker pen\", startStroke, continueStroke, cursor };\r\n}\r\n","import { useCallback } from \"react\";\r\nimport tinycolor from \"tinycolor2\";\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\nexport interface UseAirbrushProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n}\r\n\r\nexport function useAirbrush({\r\n  color = \"#000000\",\r\n  strokeWidth = 25,\r\n}: UseAirbrushProps): ToolHandlers {\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.globalCompositeOperation = \"darken\";\r\n      context.lineWidth = strokeWidth;\r\n      context.lineJoin = context.lineCap = \"round\";\r\n      context.strokeStyle = color;\r\n      context.shadowBlur = strokeWidth * 0.5;\r\n      context.shadowColor = tinycolor(color)\r\n        .setAlpha(0.5)\r\n        .toPercentageRgbString();\r\n      console.log(context.shadowColor);\r\n      context.moveTo(point[0], point[1]);\r\n      context.beginPath();\r\n    },\r\n    [color, strokeWidth]\r\n  );\r\n\r\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\r\n    context.globalCompositeOperation = \"source-over\";\r\n  }, []);\r\n\r\n  const continueStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.lineTo(point[0], point[1]);\r\n      context.stroke();\r\n    },\r\n    []\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Airbrush\", startStroke, continueStroke, endStroke, cursor };\r\n}\r\n","import { useCallback, useRef } from \"react\";\r\nimport tinycolor from \"tinycolor2\";\r\n\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nexport interface UseShadingProps {\r\n  color?: string;\r\n  neighbourColor?: string;\r\n  neighbourStrokeWidth?: number;\r\n  distanceThreshold?: number;\r\n  spreadFactor?: number;\r\n}\r\n\r\nexport function useShadingBrush({\r\n  color = \"#000000\",\r\n  neighbourColor,\r\n  distanceThreshold = 40,\r\n  neighbourStrokeWidth = 1,\r\n  spreadFactor = 0.9,\r\n}: UseShadingProps): ToolHandlers {\r\n  neighbourColor ||= tinycolor(color).setAlpha(0.2).toPercentageRgbString();\r\n  const points = useRef<Array<Point>>([]);\r\n  const threshold = distanceThreshold * distanceThreshold;\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.globalCompositeOperation = \"darken\";\r\n      context.lineWidth = 1;\r\n      context.lineJoin = context.lineCap = \"round\";\r\n      points.current = [point];\r\n    },\r\n    []\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (newPoint: Point, context: CanvasRenderingContext2D) => {\r\n      context.strokeStyle = color;\r\n      context.lineWidth = 1;\r\n\r\n      points.current.push(newPoint);\r\n      context.beginPath();\r\n      const [prevX, prevY] = points.current[points.current.length - 2];\r\n      context.moveTo(prevX, prevY);\r\n      context.lineTo(...newPoint);\r\n      context.stroke();\r\n      context.lineWidth = neighbourStrokeWidth;\r\n\r\n      for (const point of points.current) {\r\n        const dx = point[0] - newPoint[0];\r\n        const dy = point[1] - newPoint[1];\r\n        const distance = dx * dx + dy * dy;\r\n\r\n        if (distance < threshold && Math.random() > distance / threshold) {\r\n          context.beginPath();\r\n          context.strokeStyle = neighbourColor as string;\r\n          context.moveTo(\r\n            newPoint[0] + dx * spreadFactor,\r\n            newPoint[1] + dy * spreadFactor\r\n          );\r\n          context.lineTo(\r\n            point[0] - dx * spreadFactor,\r\n            point[1] - dy * spreadFactor\r\n          );\r\n          context.stroke();\r\n        }\r\n      }\r\n    },\r\n    [neighbourStrokeWidth, color, spreadFactor, threshold, neighbourColor]\r\n  );\r\n\r\n  const endStroke = useCallback((context: CanvasRenderingContext2D) => {\r\n    context.globalCompositeOperation = \"source-over\";\r\n  }, []);\r\n  const cursor = \"crosshair\";\r\n\r\n  return { name: \"Shading\", startStroke, continueStroke, endStroke, cursor };\r\n}\r\n","import { Point } from \"../../utils/pointUtils\";\r\n\r\nlet spareRandom: number | null = null;\r\n\r\n// https://gist.github.com/bluesmoon/7925696\r\nfunction normalRandom() {\r\n  let val, u, v, s, mul;\r\n  if (spareRandom !== null) {\r\n    val = spareRandom;\r\n    spareRandom = null;\r\n  } else {\r\n    do {\r\n      u = Math.random() * 2 - 1;\r\n      v = Math.random() * 2 - 1;\r\n      s = u * u + v * v;\r\n    } while (s === 0 || s >= 1);\r\n    mul = Math.sqrt((-2 * Math.log(s)) / s);\r\n    val = u * mul;\r\n    spareRandom = v * mul;\r\n  }\r\n  return val;\r\n}\r\nexport function makePolygon(\r\n  centre: Point,\r\n  sides: number,\r\n  radius: number\r\n): Array<Point> {\r\n  const increment = (Math.PI * 2) / sides;\r\n  const result: Array<Point> = [];\r\n  for (let i = 1; i <= sides; i++) {\r\n    result.push([\r\n      radius * Math.cos(increment * i) + centre[0],\r\n      radius * Math.sin(increment * i) + centre[1],\r\n    ]);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function deformPolygon(\r\n  points: Array<Point>,\r\n  depth: number,\r\n  variance: number,\r\n  vdiv: number\r\n): Array<Point> {\r\n  const newPoints: Array<Point> = [];\r\n  for (let i = 0; i < points.length; i++) {\r\n    const currentPoint = points[i];\r\n    const nextPoint = points[(i + 1) % points.length];\r\n    newPoints.push(currentPoint);\r\n    newPoints.push(\r\n      ...subdivideVertex(currentPoint, nextPoint, depth, variance, vdiv)\r\n    );\r\n  }\r\n  return newPoints;\r\n}\r\n\r\nfunction subdivideVertex(\r\n  currentPoint: Point,\r\n  nextPoint: Point,\r\n  depth: number,\r\n  variance: number,\r\n  vdiv: number\r\n): Array<Point> {\r\n  if (depth < 0) {\r\n    return [];\r\n  }\r\n  //   Find the midpoint\r\n  const midX = (currentPoint[0] + nextPoint[0]) / 2;\r\n  const midY = (currentPoint[1] + nextPoint[1]) / 2;\r\n\r\n  //   Nudge the midpoint\r\n  const newMidpoint: Point = [\r\n    midX + normalRandom() * variance,\r\n    midY + normalRandom() * variance,\r\n  ];\r\n\r\n  const newPoints = subdivideVertex(\r\n    currentPoint,\r\n    newMidpoint,\r\n    depth - 1,\r\n    variance / vdiv,\r\n    vdiv\r\n  );\r\n\r\n  newPoints.push(newMidpoint);\r\n  newPoints.push(\r\n    ...subdivideVertex(newMidpoint, nextPoint, depth - 1, variance / vdiv, vdiv)\r\n  );\r\n  return newPoints;\r\n}\r\n\r\nexport function getSplodge(\r\n  point: Point,\r\n  sides: number,\r\n  radius: number\r\n): Array<Point> {\r\n  return deformPolygon(makePolygon(point, sides, radius), 5, radius / 10, 2);\r\n}\r\n\r\nexport function splodgeAtPoint(\r\n  point: Point,\r\n  context: CanvasRenderingContext2D,\r\n  width: number\r\n): void {\r\n  context.beginPath();\r\n  getSplodge(point, Math.round(width / 5), width).forEach((point) => {\r\n    context.lineTo(...point);\r\n  });\r\n  context.closePath();\r\n  context.fill();\r\n}\r\n\r\nexport function splodgeTrail(\r\n  points: Array<Point>,\r\n  width: number,\r\n  trail: number,\r\n  context: CanvasRenderingContext2D\r\n): void {\r\n  const count = Math.min(trail, points.length / 3);\r\n  for (let i = 0; i < count; i++) {\r\n    context.globalAlpha = 0.01 - (0.009 / count) * i;\r\n    splodgeAtPoint(\r\n      points[points.length - i * 3 - 1],\r\n      context,\r\n      width + (width / count) * i\r\n    );\r\n  }\r\n  context.globalAlpha = 0.1;\r\n}\r\n","import { useCallback, useRef } from \"react\";\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\nimport { splodgeTrail } from \"./watercolor\";\r\n\r\nexport interface UseWatercolorProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n}\r\n\r\nexport function useWatercolor({\r\n  color = \"#000000\",\r\n  strokeWidth = 25,\r\n}: UseWatercolorProps): ToolHandlers {\r\n  const points = useRef<Array<Point>>([]);\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.fillStyle = color;\r\n      context.shadowColor = color;\r\n      context.globalAlpha = 0.01;\r\n      points.current = [point];\r\n      splodgeTrail(points.current, strokeWidth * 1.1, 1, context);\r\n    },\r\n    [color, strokeWidth]\r\n  );\r\n\r\n  const endStroke = useCallback(() => {\r\n    points.current = [];\r\n  }, []);\r\n\r\n  const continueStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      points.current.push(point);\r\n      splodgeTrail(points.current, strokeWidth, 5, context);\r\n    },\r\n    [strokeWidth]\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Watercolor\", startStroke, continueStroke, endStroke, cursor };\r\n}\r\n","import { useCallback } from \"react\";\r\nimport { ToolHandlers } from \"../../components/Artboard\";\r\nimport { Point } from \"../../utils/pointUtils\";\r\nimport { circleCursor } from \"../../utils/cursors\";\r\nexport interface UseEraserProps {\r\n  color?: string;\r\n  strokeWidth?: number;\r\n}\r\n\r\nexport function useEraser({ strokeWidth = 25 }: UseEraserProps): ToolHandlers {\r\n  const startStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.globalCompositeOperation = \"source-over\";\r\n\r\n      context.lineWidth = strokeWidth;\r\n      context.strokeStyle = \"#ffffff\";\r\n      context.lineJoin = context.lineCap = \"round\";\r\n      context.moveTo(point[0], point[1]);\r\n      context.beginPath();\r\n    },\r\n    [strokeWidth]\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (point: Point, context: CanvasRenderingContext2D) => {\r\n      context.lineTo(point[0], point[1]);\r\n      context.stroke();\r\n    },\r\n    []\r\n  );\r\n\r\n  const cursor = circleCursor(strokeWidth);\r\n\r\n  return { name: \"Eraser\", startStroke, continueStroke, cursor };\r\n}\r\n","export type Point = [number, number];\r\n\r\nexport const getTouchPoint = (event: React.TouchEvent): Point => {\r\n  if (!event.currentTarget) {\r\n    return [0, 0];\r\n  }\r\n  const rect = event.currentTarget.getBoundingClientRect();\r\n  const touch = event.targetTouches[0];\r\n  return [touch.clientX - rect.left, touch.clientY - rect.top];\r\n};\r\n\r\nexport const getMousePoint = (event: React.MouseEvent): Point => [\r\n  event.nativeEvent.offsetX,\r\n  event.nativeEvent.offsetY,\r\n];\r\n\r\nconst BUTTON = 0b01;\r\nexport const mouseButtonIsDown = (buttons: number): boolean =>\r\n  (BUTTON & buttons) === BUTTON;\r\n","import React, {\r\n  ForwardedRef,\r\n  forwardRef,\r\n  useCallback,\r\n  useImperativeHandle,\r\n  useState,\r\n} from \"react\";\r\n\r\nimport { History } from \"../history\";\r\n\r\nimport {\r\n  getMousePoint,\r\n  getTouchPoint,\r\n  mouseButtonIsDown,\r\n  Point,\r\n} from \"../utils/pointUtils\";\r\n\r\nexport interface ArtboardProps\r\n  extends React.CanvasHTMLAttributes<HTMLCanvasElement> {\r\n  tool: ToolHandlers;\r\n  history?: History;\r\n  onStartStroke?: (point: Point) => void;\r\n  onContinueStroke?: (point: Point) => void;\r\n  onEndStroke?: () => void;\r\n}\r\n\r\nexport interface ArtboardRef {\r\n  download: (filename?: string, type?: string) => void;\r\n  getImageAsDataUri: (type?: string) => string | undefined;\r\n  clear: () => void;\r\n  context?: CanvasRenderingContext2D | null;\r\n}\r\n\r\nexport interface ToolHandlers {\r\n  name: string;\r\n  startStroke?: (point: Point, context: CanvasRenderingContext2D) => void;\r\n  continueStroke?: (point: Point, context: CanvasRenderingContext2D) => void;\r\n  endStroke?: (context: CanvasRenderingContext2D) => void;\r\n  cursor?: string;\r\n}\r\n\r\nexport const Artboard = forwardRef(function Artboard(\r\n  {\r\n    tool,\r\n    style,\r\n    history,\r\n    onStartStroke,\r\n    onContinueStroke,\r\n    onEndStroke,\r\n    ...props\r\n  }: ArtboardProps,\r\n  ref: ForwardedRef<ArtboardRef>\r\n) {\r\n  const [context, setContext] = useState<CanvasRenderingContext2D | null>();\r\n  const [canvas, setCanvas] = useState<HTMLCanvasElement>();\r\n  const [drawing, setDrawing] = useState(false);\r\n\r\n  const startStroke = useCallback(\r\n    (point: Point) => {\r\n      if (!context) {\r\n        return;\r\n      }\r\n      context.save();\r\n      setDrawing(true);\r\n      tool.startStroke?.(point, context);\r\n      onStartStroke?.(point);\r\n    },\r\n    [tool, context, onStartStroke]\r\n  );\r\n\r\n  const continueStroke = useCallback(\r\n    (newPoint: Point) => {\r\n      if (!context) {\r\n        return;\r\n      }\r\n      tool.continueStroke?.(newPoint, context);\r\n      onContinueStroke?.(newPoint);\r\n    },\r\n    [tool, context, onContinueStroke]\r\n  );\r\n\r\n  const endStroke = useCallback(() => {\r\n    setDrawing(false);\r\n    if (context) {\r\n      tool.endStroke?.(context);\r\n      onEndStroke?.();\r\n      context.restore();\r\n      if (canvas && history) {\r\n        history.pushState(canvas);\r\n      }\r\n    }\r\n  }, [tool, context, canvas, history, onEndStroke]);\r\n\r\n  const mouseMove = useCallback(\r\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (!drawing) {\r\n        return;\r\n      }\r\n      continueStroke(getMousePoint(event));\r\n    },\r\n    [continueStroke, drawing]\r\n  );\r\n\r\n  const touchMove = useCallback(\r\n    (event: React.TouchEvent) => {\r\n      if (!drawing) {\r\n        return;\r\n      }\r\n      continueStroke(getTouchPoint(event));\r\n    },\r\n    [continueStroke, drawing]\r\n  );\r\n\r\n  const mouseDown = useCallback(\r\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (drawing) {\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      startStroke(getMousePoint(event));\r\n    },\r\n    [drawing, startStroke]\r\n  );\r\n\r\n  const touchStart = useCallback(\r\n    (event: React.TouchEvent) => {\r\n      if (drawing) {\r\n        return;\r\n      }\r\n      startStroke(getTouchPoint(event));\r\n    },\r\n    [drawing, startStroke]\r\n  );\r\n\r\n  const clear = useCallback(() => {\r\n    if (!context || !canvas) {\r\n      return;\r\n    }\r\n    context.save();\r\n    context.fillStyle = \"rgba(255, 255, 255, 0)\";\r\n    context.fillRect(0, 0, canvas.width, canvas.height);\r\n    context.restore();\r\n    if (canvas && history) {\r\n      history.pushState(canvas);\r\n    }\r\n  }, [context, canvas, history]);\r\n\r\n  const gotRef = useCallback(\r\n    (canvasRef: HTMLCanvasElement) => {\r\n      if (!canvasRef) {\r\n        return;\r\n      }\r\n      canvasRef.width = canvasRef.offsetWidth;\r\n      canvasRef.height = canvasRef.offsetHeight;\r\n      const ctx = canvasRef.getContext(\"2d\");\r\n      setCanvas(canvasRef);\r\n      setContext(ctx);\r\n      if (!ctx) {\r\n        return;\r\n      }\r\n      ctx.fillStyle = \"rgba(255, 255, 255, 0)\";\r\n      ctx.fillRect(0, 0, canvasRef.width, canvasRef.height);\r\n      ctx.fillStyle = \"transparent\";\r\n      if (history) {\r\n        history.setContext(ctx);\r\n        history.pushState(canvasRef);\r\n      }\r\n    },\r\n    [history]\r\n  );\r\n\r\n  const mouseEnter = useCallback(\r\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (mouseButtonIsDown(event.buttons)) {\r\n        mouseDown(event);\r\n      } else if (drawing) {\r\n        endStroke();\r\n      }\r\n    },\r\n    [drawing, mouseDown, endStroke]\r\n  );\r\n\r\n  const mouseLeave = useCallback(\r\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\r\n      if (!drawing) {\r\n        return;\r\n      }\r\n      continueStroke(getMousePoint(event));\r\n      endStroke();\r\n    },\r\n    [continueStroke, drawing, endStroke]\r\n  );\r\n\r\n  useImperativeHandle(\r\n    ref,\r\n    () => ({\r\n      download: (filename = \"image.png\", type?: string) => {\r\n        if (!canvas) {\r\n          return;\r\n        }\r\n        const a = document.createElement(\"a\");\r\n        a.href = canvas.toDataURL(type);\r\n        a.download = filename;\r\n        a.click();\r\n      },\r\n      clear,\r\n      getImageAsDataUri: (type?: string) => canvas?.toDataURL(type),\r\n      context,\r\n    }),\r\n    [canvas, context, clear]\r\n  );\r\n\r\n  return (\r\n    <canvas\r\n      style={{ cursor: tool?.cursor, touchAction: \"none\", ...style }}\r\n      onTouchStart={touchStart}\r\n      onMouseDown={mouseDown}\r\n      onMouseEnter={mouseEnter}\r\n      onMouseMove={drawing ? mouseMove : undefined}\r\n      onTouchMove={drawing ? touchMove : undefined}\r\n      onMouseUp={endStroke}\r\n      onMouseOut={mouseLeave}\r\n      onTouchEnd={endStroke}\r\n      ref={gotRef}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\n","import { useCallback, useMemo, useRef, useState } from \"react\";\r\n\r\nasync function applyImage(context: CanvasRenderingContext2D, blob: Blob) {\r\n  const img = new Image();\r\n  img.onload = () => {\r\n    context.canvas.width = img.width;\r\n    context.canvas.height = img.height;\r\n    context.drawImage(img, 0, 0);\r\n    URL.revokeObjectURL(img.src);\r\n  };\r\n  img.src = URL.createObjectURL(blob);\r\n}\r\n\r\nexport interface History {\r\n  setContext: (context: CanvasRenderingContext2D) => void;\r\n  pushState: (canvas: HTMLCanvasElement) => Promise<boolean>;\r\n}\r\nexport interface HistoryHook {\r\n  history: History;\r\n\r\n  undo: () => Promise<boolean>;\r\n  redo: () => Promise<boolean>;\r\n  clear: () => void;\r\n  canUndo: boolean;\r\n  canRedo: boolean;\r\n}\r\n\r\nexport function useHistory(size?: number): HistoryHook {\r\n  const stack = useRef<Array<Blob>>([]);\r\n  const crs = useRef(0);\r\n  const [context, setContext] = useState<CanvasRenderingContext2D>();\r\n  const [canUndo, setCanUndo] = useState(false);\r\n  const [canRedo, setCanRedo] = useState(false);\r\n\r\n  const pushState = useCallback(\r\n    async (canvas: HTMLCanvasElement) => {\r\n      const undoCursor = crs.current;\r\n      if (!context) {\r\n        console.error(\"Context not initialised\");\r\n        return false;\r\n      }\r\n      if (undoCursor !== 0) {\r\n        stack.current = stack.current.slice(0, -undoCursor);\r\n        crs.current = 0;\r\n      }\r\n      const blob = await new Promise<Blob | null>((resolve) =>\r\n        canvas.toBlob(resolve)\r\n      );\r\n      if (blob) {\r\n        stack.current.push(blob);\r\n      }\r\n      if (size && stack.current.length > size) {\r\n        stack.current = stack.current.slice(-size);\r\n      }\r\n      setCanUndo(stack.current.length > 1);\r\n      setCanRedo(false);\r\n      return true;\r\n    },\r\n    [crs, stack, context]\r\n  );\r\n  const undo = useCallback(async () => {\r\n    const undoCursor = crs.current;\r\n\r\n    if (!context) {\r\n      console.error(\"Context not initialised\");\r\n      return false;\r\n    }\r\n    if (undoCursor + 1 >= stack.current.length) {\r\n      console.log(\"nope\");\r\n      return false;\r\n    }\r\n\r\n    await applyImage(\r\n      context,\r\n      stack.current[stack.current.length - (undoCursor + 2)]\r\n    );\r\n    crs.current++;\r\n    setCanUndo(crs.current + 1 < stack.current.length);\r\n    setCanRedo(true);\r\n    return true;\r\n  }, [crs, stack, context]);\r\n\r\n  const redo = useCallback(async () => {\r\n    const undoCursor = crs.current;\r\n\r\n    if (!context) {\r\n      console.error(\"Context not initialised\");\r\n      return false;\r\n    }\r\n    if (undoCursor <= 0) {\r\n      return false;\r\n    }\r\n\r\n    await applyImage(context, stack.current[stack.current.length - undoCursor]);\r\n    crs.current--;\r\n    setCanUndo(crs.current + 1 < stack.current.length);\r\n    setCanRedo(crs.current > 0);\r\n    return true;\r\n  }, [stack, crs, context]);\r\n\r\n  const clear = useCallback(() => {\r\n    stack.current = [];\r\n  }, [stack]);\r\n\r\n  const history = useMemo<History>(\r\n    () => ({\r\n      setContext: (context: CanvasRenderingContext2D) => {\r\n        setContext(context);\r\n      },\r\n      pushState,\r\n    }),\r\n    [setContext, pushState]\r\n  );\r\n\r\n  return { history, undo, redo, clear, canUndo, canRedo };\r\n}\r\n"],"names":["varyColour","sourceColour","varyBrightness","amount","Math","round","random","alpha","tinycolor","darken","setAlpha","toPercentageRgbString","rotatePoint","distance","angle","origin","cos","sin","circleCursor","diameter","btoa","circleSVG","circleDataUri","useBrush","color","strokeWidth","brush","setBrush","useState","currentAngle","useRef","lastPoint","startStroke","useCallback","point","current","undefined","colour","bristleCount","gap","i","push","thickness","makeBrush","name","continueStroke","newPoint","context","newAngle","getNewAngle","destination","oldAngle","bearing","getBearing","atan2","PI","angleDiff","angleA","angleB","twoPi","diff","drawStroke","bristles","forEach","bristle","beginPath","strokeBristle","controlPoint","moveTo","strokeStyle","lineWidth","lineCap","lineJoin","shadowColor","shadowBlur","quadraticCurveTo","lineTo","stroke","cursor","useMarker","offset","globalAlpha","useAirbrush","globalCompositeOperation","console","log","endStroke","useShadingBrush","neighbourColor","distanceThreshold","neighbourStrokeWidth","spreadFactor","points","threshold","prevX","prevY","length","dx","dy","spareRandom","normalRandom","val","u","v","s","mul","sqrt","subdivideVertex","currentPoint","nextPoint","depth","variance","vdiv","midY","newMidpoint","newPoints","splodgeAtPoint","width","sides","radius","deformPolygon","centre","increment","result","makePolygon","getSplodge","closePath","fill","splodgeTrail","trail","count","min","useWatercolor","fillStyle","useEraser","getTouchPoint","event","currentTarget","rect","getBoundingClientRect","touch","targetTouches","clientX","left","clientY","top","getMousePoint","nativeEvent","offsetX","offsetY","mouseButtonIsDown","buttons","Artboard","forwardRef","_ref","ref","tool","style","history","onStartStroke","onContinueStroke","onEndStroke","props","_objectWithoutPropertiesLoose","_excluded","setContext","canvas","setCanvas","drawing","setDrawing","save","restore","pushState","mouseMove","touchMove","mouseDown","preventDefault","touchStart","clear","fillRect","height","gotRef","canvasRef","offsetWidth","offsetHeight","ctx","getContext","mouseEnter","mouseLeave","useImperativeHandle","download","filename","type","a","document","createElement","href","toDataURL","click","getImageAsDataUri","React","_extends","touchAction","onTouchStart","onMouseDown","onMouseEnter","onMouseMove","onTouchMove","onMouseUp","onMouseOut","onTouchEnd","async","applyImage","blob","img","Image","onload","drawImage","URL","revokeObjectURL","src","createObjectURL","useHistory","size","stack","crs","canUndo","setCanUndo","canRedo","setCanRedo","undoCursor","error","slice","Promise","resolve","toBlob","undo","redo","useMemo"],"mappings":"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"}